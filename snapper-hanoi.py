#!/usr/bin/env python2

import math
import optparse
import re
import subprocess
import sys
import time
from collections import defaultdict

parser = optparse.OptionParser()
parser.add_option('-p', '--prefix', default='hanoi', help='The prefix to use on snapshots generated by this program.')
parser.add_option('-s', '--snapper', default='snapper', help='Path to the snapper executable, if not in $PATH.')
parser.add_option('-m', '--keep-min', type='int', default=1, help='The minimum number of consecutive recent snapshots to keep.')
parser.add_option('-v', '--verbose', action='store_true', help='Be verbose about what we\'re doing.')
parser.add_option('-t', '--tapes', type='int', default=sys.maxint, help='number of tapes that we theoretically have')
parser.add_option('-n', '--number-tape', type='int', default=1, help='number of backups per tape that we theoretically have')

(options, args) = parser.parse_args()

class SnapshotList:
    def __init__(self):
        self.snapshots = []

    def add(self, snapshot_name):
        #m = re.search('^(?:[^@]+@)?%s_[^_]+_([0-9a-f]+)$' % re.escape(options.prefix), snapshot_name)
        m = re.search('\s*(\d+)\s*\|.+\|\s+%s_[^_]+_([0-9a-f]+)\s+' % re.escape(options.prefix),snapshot_name)
        if m:
            #print m.group(1),m.group(2)
            self.snapshots.append((int(m.group(2), 16), snapshot_name,int(m.group(1))))
        elif options.verbose:
            print 'Skipping snapshot:', snapshot_name

    @property
    def max_counter(self):
        if len(self.snapshots) == 0:
            return 0
        else:
            return max([counter for counter, name, number in self.snapshots])

    def find_tape(counter):
            for j in xrange(0, options.tapes):
                i = 0
                while True:
                    #print 'j',j,'i',i
                    if ((2 ** (j + 1)) * i + (2 ** j) == counter):
                        return j
                    if (2 ** (j + 1)) * i + (2 ** j) > counter:
                        break
                    i += 1
            else:
                return j

    def next_snapshot(self):
        return '%s_%s_%05x' % (options.prefix, time.strftime('%Y-%m-%dT%H:%M%z'), self.max_counter + 1)

    def obsolete_snapshots(self):
        if self.max_counter <= 0:
            return
        ordered_snapshots = list(reversed(sorted(self.snapshots)))
        valid_indices = set([i for i, name, number in ordered_snapshots[:options.keep_min]])
        tapedictionary = defaultdict(list)
        for index,name,number in ordered_snapshots:
            tape=find_tape(index)
            tapedictionary[tape].append(index)
        for tape in tapedictionary.keys():
            days_per_tape_list=tapedictionary[tape]
            days_per_tape_list=days_per_tape_list[:options.number_tape]
            if options.verbose:
                print 'valid indices for tape',str(tape),'are:',' '.join([str(i) for i in days_per_tape_list])
            for index in days_per_tape_list:
                valid_indices.add(index)
        if options.verbose:
            print 'valid indices are:', ' '.join([str(i) for i in sorted(valid_indices)])
        for i, name, number in self.snapshots:
            if i not in valid_indices:
                yield number

def generate_list(dataset):
    snapshots = SnapshotList()
    cmd = [options.snapper, '-c', dataset, 'list']
    if options.verbose:
        print 'running:', ' '.join(cmd)
    snapper_list = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    lines, ignored = snapper_list.communicate()
    for line in lines.split('\n'):
        #print line
        snapshots.add(line)
    return snapshots


dataset=args[0]
snapshots = generate_list(dataset)
cmd = [options.snapper,'-c',dataset,'create','--description',snapshots.next_snapshot()]
if options.verbose:
  print 'running:', ' '.join(cmd)
subprocess.call(cmd)
snapshots = generate_list(dataset)
for obsolete in snapshots.obsolete_snapshots():
    cmd = [options.snapper,'-c',dataset, 'delete',str(obsolete)]
    if options.verbose:
       print 'running:', ' '.join(cmd)
    subprocess.call(cmd)
