#!/usr/bin/env python2

import math
import optparse
import re
import subprocess
import sys
import time
from collections import defaultdict

parser = optparse.OptionParser()
parser.add_option('-p', '--prefix', default='hanoi', help='The prefix to use on snapshots generated by this program.')
parser.add_option('-s', '--snapper', default='snapper', help='Path to the snapper executable, if not in $PATH.')
parser.add_option('-m', '--keep-min', type='int', default=1, help='The minimum number of consecutive recent snapshots to keep.')
parser.add_option('-v', '--verbose', action='store_true', help='Be verbose about what we\'re doing.')
parser.add_option('-t', '--tapes', type='int', default=sys.maxint, help='number of tapes that we theoretically have')
parser.add_option('-n', '--number-tape', type='int', default=1, help='number of backups per tape that we theoretically have')
parser.add_option('-d', '--diff', action='store_true', help='keep new snapshot only if it differs from the previous snapshot')


(options, args) = parser.parse_args()

#tape 0 contains days modulo 2 == 1
#tape 1 contains days modulo 4 == 2
#tape n contains days modulo 2^(n+1) == 2^n
#modulo 2^n can be replaced by bitwise and with 2^n - 1 (in binary 111111...)
def find_tape(counter):
            power_of_two=1
            for j in xrange(0, options.tapes):
                modulo_mask=(power_of_two<<1) - 1
                if counter & modulo_mask == power_of_two:
                    return j
                power_of_two<<=1
            else:
                return j

class SnapshotList:
    def __init__(self):
        self.snapshots = []

    def add(self, snapshot_name):
        #m = re.search('^(?:[^@]+@)?%s_[^_]+_([0-9a-f]+)$' % re.escape(options.prefix), snapshot_name)
        m = re.search('\s*(\d+)\s*\|.+\|\s+%s_[^_]+_([0-9a-f]+)\s+' % re.escape(options.prefix),snapshot_name)
        if m:
            #print m.group(1),m.group(2)
            self.snapshots.append((int(m.group(2), 16),int(m.group(1))))
        elif options.verbose:
            print 'Skipping snapshot:', snapshot_name

    @property
    def max_counter(self):
        if len(self.snapshots) == 0:
            return 0
        else:
            return max([counter for counter, number in self.snapshots])

    def next_snapshot(self):
        return '%s_%s_%05x' % (options.prefix, time.strftime('%Y-%m-%dT%H:%M%z'), self.max_counter + 1)

    def obsolete_snapshots(self):
        if self.max_counter <= 0:
            return
        ordered_snapshots = list(reversed(sorted(self.snapshots)))
        valid_indices = set(ordered_snapshots[:options.keep_min])
        tapedictionary = defaultdict(list)
        for pair in ordered_snapshots[options.keep_min:]:
            #print pair
            tape=find_tape(pair[0])
            tapedictionary[tape].append(pair)
        for tape in tapedictionary.keys():
            days_per_tape_list=tapedictionary[tape]
            days_per_tape_list=days_per_tape_list[:options.number_tape]
            if options.verbose:
                print 'valid indices for tape',str(tape),'are:',' '.join([str(i) for i in days_per_tape_list])
            for index in days_per_tape_list:
                valid_indices.add(index)
        if options.verbose:
            print 'valid indices are:', ' '.join([str(i) for i in sorted(valid_indices)])
        for i, number in set(self.snapshots)-valid_indices:
            yield number

def generate_list(dataset):
    snapshots = SnapshotList()
    cmd = [options.snapper, '-c', dataset, 'list']
    if options.verbose:
        print 'running:', ' '.join(cmd)
    snapper_list = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    lines, ignored = snapper_list.communicate()
    for line in lines.split('\n'):
        #print line
        snapshots.add(line)
    return snapshots


dataset=args[0]
snapshots = generate_list(dataset)
cmd = [options.snapper,'-c',dataset,'create','--description',snapshots.next_snapshot()]
if options.verbose:
  print 'running:', ' '.join(cmd)
subprocess.call(cmd)
snapshots = generate_list(dataset)

if options.diff:
  top_snapshots=list(reversed(sorted(snapshots.snapshots)))[:2]
  cmd1 = [options.snapper,'-c',dataset,'status',str(top_snapshots[1][1])+'..'+str(top_snapshots[0][1])]
  cmd2 = ['wc','-l']
  if options.verbose:
    print 'running:',' '.join(cmd1),'|', ' '.join(cmd2)
  p1=subprocess.Popen(cmd1, stdout=subprocess.PIPE)
  p2=subprocess.Popen(cmd2,stdin=p1.stdout,stdout=subprocess.PIPE)
  p1.stdout.close()
  diff=int(p2.communicate()[0].strip())
  if diff == 0:
    cmd = [options.snapper,'-c',dataset, 'delete',str(top_snapshots[0][1])]
    if options.verbose:
      print 'running:', ' '.join(cmd)
    print 'No differences between current and previous snapshot, deleting'
    subprocess.call(cmd)
    snapshots = generate_list(dataset)
  else:
    print 'Found differences between current and previous snapshot'

for obsolete in snapshots.obsolete_snapshots():
    cmd = [options.snapper,'-c',dataset, 'delete',str(obsolete)]
    if options.verbose:
       print 'running:', ' '.join(cmd)
    subprocess.call(cmd)
